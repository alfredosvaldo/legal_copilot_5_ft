<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Copiloto Legal — Comparador Legislativo Multiartículo</title>

<!-- UI -->
<script src="https://cdn.tailwindcss.com"></script>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

<!-- Utilidades -->
<script src="https://unpkg.com/html-docx-js/dist/html-docx.js"></script>
<script src="https://unpkg.com/file-saver@2.0.5/dist/FileSaver.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/diff@5.1.0/dist/diff.min.js"></script>

<style>
  body { font-family: 'Inter', sans-serif; }
  ins { background:#d4edda; text-decoration:none; }
  del { background:#f8d7da; text-decoration:line-through; }
  .loader{border:4px solid #f3f3f3;border-top:4px solid #2563eb;border-radius:50%;width:40px;height:40px;animation:spin 1s linear infinite;margin:2rem auto;}
  @keyframes spin{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}
  #resultsTable th,#resultsTable td{border:1px solid #e5e7eb;padding:10px;vertical-align:top}
  #resultsTable th{background:#f8fafc;text-align:left}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,'Liberation Mono','Courier New',monospace}
</style>
</head>
<body class="bg-gray-100 text-gray-800 min-h-screen flex flex-col">

<div class="container mx-auto p-4 md:p-8 flex-1">
  <header class="mb-6">
    <h1 class="text-3xl md:text-4xl font-bold">Copiloto Legal — Comparador Multiartículo</h1>
    <p class="text-gray-600">Procesa TODOS los artículos • Indicaciones vacías si no hay cambios • Renumeración global • Exportar a Word.</p>
  </header>

  <!-- Config -->
  <section class="bg-white p-5 rounded-lg shadow mb-6 grid gap-4 md:grid-cols-3">
    <div class="md:col-span-2">
      <label class="block font-semibold mb-2">OpenAI API Key</label>
      <input type="password" id="apiKey" class="w-full p-3 border rounded-md focus:ring-2 focus:ring-blue-500" placeholder="Pega tu API key"/>
      <p class="text-sm text-gray-500 mt-1">Se usa sólo en tu navegador.</p>
    </div>
    <div>
      <label class="block font-semibold mb-2">Modelo</label>
      <input type="text" id="modelName" class="w-full p-3 border rounded-md focus:ring-2 focus:ring-blue-500 mono" value="gpt-4o"/>
      <p class="text-xs text-gray-500 mt-1">También puedes usar tu modelo fine-tuned (p. ej. <span class="mono">ft:...</span>).</p>
    </div>
    <div class="md:col-span-3 flex items-center gap-3">
      <input id="remember" type="checkbox" class="h-4 w-4" checked/>
      <label for="remember" class="text-sm text-gray-700">Recordar API key/modelo en este navegador</label>
    </div>
  </section>

  <!-- Inputs -->
  <section class="grid gap-6 md:grid-cols-2">
    <div class="bg-white p-5 rounded-lg shadow">
      <div class="flex items-center justify-between mb-2">
        <h2 class="text-xl font-semibold">Texto Original (completo)</h2>
        <button id="pasteOriginal" class="text-sm text-blue-600 hover:underline">Pegar</button>
      </div>
      <textarea id="originalText" class="w-full h-96 p-3 border rounded-md focus:ring-2 focus:ring-blue-500" placeholder="Pega aquí el texto original completo…"></textarea>
    </div>
    <div class="bg-white p-5 rounded-lg shadow">
      <div class="flex items-center justify-between mb-2">
        <h2 class="text-xl font-semibold">Texto Final (completo)</h2>
        <button id="pasteFinal" class="text-sm text-blue-600 hover:underline">Pegar</button>
      </div>
      <textarea id="finalText" class="w-full h-96 p-3 border rounded-md focus:ring-2 focus:ring-blue-500" placeholder="Pega aquí el texto final completo…"></textarea>
    </div>
  </section>

  <!-- Acciones -->
  <div class="flex flex-wrap gap-3 justify-center my-8">
    <button id="generateButton" class="bg-green-600 text-white font-bold py-3 px-6 rounded-lg shadow hover:bg-green-700 focus:ring-4 focus:ring-green-300 disabled:bg-gray-400">Generar tabla comparativa</button>
    <button id="exportButton" class="bg-blue-600 text-white font-bold py-3 px-6 rounded-lg shadow hover:bg-blue-700">Exportar a Word</button>
    <button id="clearButton" class="bg-gray-200 text-gray-800 font-semibold py-3 px-6 rounded-lg shadow hover:bg-gray-300">Limpiar</button>
  </div>

  <!-- Resultados -->
  <section id="outputSection" class="bg-white p-5 rounded-lg shadow hidden">
    <div class="flex items-center justify-between mb-3">
      <h3 class="text-xl font-semibold">Resultado <span id="timerResult" class="text-sm font-normal text-gray-500 ml-2"></span></h3>
      <span id="modelUsed" class="text-xs text-gray-500 mono"></span>
    </div>
    <div id="resultsContainer" class="w-full overflow-x-auto"></div>
    <details class="mt-4">
      <summary class="cursor-pointer text-sm text-gray-600">Registro de análisis (debug)</summary>
      <pre id="debugLog" class="text-xs bg-gray-50 border rounded p-3 overflow-auto max-h-64 whitespace-pre-wrap"></pre>
    </details>
  </section>

  <!-- Errores -->
  <div id="errorBox" class="hidden mt-4 p-4 rounded bg-red-50 border border-red-200 text-red-700"></div>
</div>

<footer class="text-center p-4 text-gray-500 text-sm">
  Copiloto Legal — Cliente 100% local
</footer>

<script>
/* ================= Helpers UI ================= */
const $ = (id)=>document.getElementById(id);
(function boot(){
  const k = localStorage.getItem("openai_key");
  const m = localStorage.getItem("openai_model");
  if (k) $("apiKey").value = k;
  if (m) $("modelName").value = m;
})();
$("remember").addEventListener("change",(e)=>{ if(!e.target.checked){ localStorage.removeItem("openai_key"); localStorage.removeItem("openai_model"); }});
$("pasteOriginal").onclick = async()=>{ try{$("originalText").value = await navigator.clipboard.readText();}catch{} };
$("pasteFinal").onclick    = async()=>{ try{$("finalText").value    = await navigator.clipboard.readText();}catch{} };
$("clearButton").onclick   = ()=>{ $("resultsContainer").innerHTML=""; $("outputSection").classList.add("hidden"); $("timerResult").textContent=""; $("debugLog").textContent=""; hideError(); };

function showError(msg){ const box=$("errorBox"); box.textContent=msg; box.classList.remove("hidden"); console.error(msg); }
function hideError(){ $("errorBox").classList.add("hidden"); }
function dlog(...a){ $("debugLog").textContent += a.join(" ") + "\n"; console.log(...a); }
function escapeHtml(s){ return (s||"").replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;"); }
function sanitize(s){ return escapeHtml(s).replace(/\n/g,"<br>"); }

/* ============== Segmentación artículos (maneja bis/ter/… y transitorios) ============== */
const SUF_RE = "(?:bis|ter|qu(?:á|a)ter|quinquies|sexies|septies|octies|nonies|decies)";

function normalizeHeader(h){ return (h||"").replace(/\s+/g," ").trim().replace(/^Artículo\s+/i,"Artículo "); }
function romanToInt(str){
  const s=(str||"").toUpperCase().replace(/[^IVXLCDM]/g,"");
  if(!s) return null;
  const map={I:1,V:5,X:10,L:50,C:100,D:500,M:1000};
  let v=0,p=0; for(let i=s.length-1;i>=0;i--){ const n=map[s[i]]; v += n<p ? -n : n; p=n; }
  return v||null;
}
function makeKeyFromHeader(header){
  let h = header.toLowerCase().normalize("NFKD").replace(/[\u0300-\u036f]/g,"").replace(/\s+/g," ").trim();

  const mNum = h.match(new RegExp(`^articulo\\s+(\\d+)[°º]?\\s*(?:(${SUF_RE}))?(?:\\s+transitorio)?$`,"i"));
  if (mNum){
    const n = mNum[1];
    const suf = mNum[2] ? " " + mNum[2].replace("quáter","quater") : "";
    const trans = /\btransitorio\b/i.test(h) ? " transitorio" : "";
    return (`artículo ${n}${suf}${trans}`).trim();
  }
  const mRom = h.match(/^articulo\s+([ivxlcdm]+)(?:\s+transitorio)?$/i);
  if (mRom){
    const n = romanToInt(mRom[1]) || mRom[1];
    const trans = /\btransitorio\b/i.test(h) ? " transitorio" : "";
    return (`artículo ${n}${trans}`).trim();
  }
  const ord={'primero':'1','segundo':'2','tercero':'3','cuarto':'4','quinto':'5','sexto':'6','septimo':'7','séptimo':'7','octavo':'8','noveno':'9','decimo':'10','décimo':'10'};
  const mWord = h.match(/^articulo\s+([a-zñ]+)(?:\s+transitorio)?$/i);
  if (mWord && ord[mWord[1]]){
    const trans = /\btransitorio\b/i.test(h) ? " transitorio" : "";
    return (`artículo ${ord[mWord[1]]}${trans}`).trim();
  }
  return h;
}
function splitArticles(text){
  const src = (text||"").replace(/\r\n/g,"\n");
  const re = new RegExp(
    `(^|\\n)[ \\t]*(Artículo\\s+(?:\\d+[°º]?(?:\\s*${SUF_RE})?|[ivxlcdm]+|[A-Za-zÁÉÍÓÚÑáéíóúñ]+)(?:\\s+transitorio)?)(?:\\s*(?:\\.-|\\.|:))?`,
    "gmi"
  );
  const blocks=[]; let m, marks=[];
  while((m=re.exec(src))!==null){
    marks.push({start:m.index + (m[1]?m[1].length:0), header:m[2], end:re.lastIndex});
  }
  for(let i=0;i<marks.length;i++){
    const cur=marks[i], next=marks[i+1];
    blocks.push({
      header: normalizeHeader(cur.header),
      body: src.slice(cur.end, next?next.start:src.length).trim()
    });
  }
  blocks.forEach(b=>{ b.key=makeKeyFromHeader(b.header); b.text=b.body; });
  return blocks;
}

/* ============== Emparejado A/B/C/D ============== */
function tokenizeSafe(t){ return (t||"").toLowerCase().normalize("NFKD").replace(/[\u0300-\u036f]/g,"").match(/[a-z0-9]+/g)||[]; }
function jaccard(a,b){ const A=new Set(tokenizeSafe(a)), B=new Set(tokenizeSafe(b)); let inter=0; A.forEach(x=>{if(B.has(x)) inter++;}); const uni=new Set([...A,...B]).size||1; return inter/uni; }
function pairArticles(OB, FB){
  const oMap=new Map(OB.map(b=>[b.key,b])); const fMap=new Map(FB.map(b=>[b.key,b]));
  const usedF=new Set(); const pairs=[];
  for(const [k,o] of oMap){ if(fMap.has(k)){ const f=fMap.get(k); usedF.add(k); pairs.push({type:'A', original:o, final:f}); } }
  for(const [k,f] of fMap){ if(!oMap.has(k) && !usedF.has(k)){ usedF.add(k); pairs.push({type:'B', original:null, final:f}); } }
  for(const [k,o] of oMap){
    if(pairs.find(p=>p.original?.key===k)) continue;
    let best=null, bestS=0;
    for(const [kf,f] of fMap){ if(usedF.has(kf)) continue; const s=jaccard(o.text, f.text); if(s>bestS){ bestS=s; best={kf,f}; } }
    if(bestS>=0.99){ usedF.add(best.kf); pairs.push({type:'D', original:o, final:best.f}); }
    else { pairs.push({type:'C', original:o, final:null}); }
  }
  return pairs;
}

/* === ORDEN FUSIONADO: Final para A/B/D y Original para C (eliminados quedan in situ) === */
function indexMap(blocks){ const m=new Map(); blocks.forEach((b,i)=>m.set(b.key,i)); return m; }
function orderPairsMerged(pairs, OB, FB){
  const oIdx = indexMap(OB), fIdx = indexMap(FB);
  const byFinal=new Map(), byOriginal=new Map();
  for(const p of pairs){ if(p.final) byFinal.set(p.final.key,p); if(p.original) byOriginal.set(p.original.key,p); }

  const mergedKeys=[]; let i=0,j=0;
  while(i<OB.length || j<FB.length){
    const ko = i<OB.length ? OB[i].key : null;
    const kf = j<FB.length ? FB[j].key : null;
    if(ko && kf && ko===kf){ mergedKeys.push(kf); i++; j++; continue; }
    if(ko && !fIdx.has(ko)){ mergedKeys.push(ko); i++; continue; }
    if(kf && !oIdx.has(kf)){ mergedKeys.push(kf); j++; continue; }
    if(ko && kf){
      const posKoEnF=fIdx.get(ko), posKfEnO=oIdx.get(kf);
      if(posKoEnF<=posKfEnO){ mergedKeys.push(ko); i++; } else { mergedKeys.push(kf); j++; }
      continue;
    }
    if(ko){ mergedKeys.push(ko); i++; }
    else if(kf){ mergedKeys.push(kf); j++; }
  }
  const out=[], seen=new Set();
  for(const k of mergedKeys){
    const p = byFinal.get(k) || byOriginal.get(k);
    if(p && !seen.has(p)){ out.push(p); seen.add(p); }
  }
  for(const p of pairs){ if(!seen.has(p)){ out.push(p); seen.add(p); } }
  return out;
}

/* ============== Igualdad (sin cambios) ============== */
function normalizeForEquality(t){
  return (t||"").replace(/\r\n/g,"\n").replace(/[ \t]+/g," ")
    .replace(/\s+\n/g,"\n").replace(/\n\s+/g,"\n").trim();
}
function isNoChange(a,b){ const A=normalizeForEquality(a), B=normalizeForEquality(b); if(A===B) return true; return jaccard(A,B)>=0.999; }

/* ============== Incisos: romanos o párrafos (para “nuevo inciso segundo”) ============== */
const ROMANS=["i","ii","iii","iv","v","vi","vii","viii","ix","x","xi","xii","xiii","xiv","xv","xvi","xvii","xviii","xix","xx"];
const ORD=["primero","segundo","tercero","cuarto","quinto","sexto","séptimo","octavo","noveno","décimo","undécimo","duodécimo","decimotercero","decimocuarto","decimoquinto","decimosexto","decimoséptimo","decimoctavo","decimonoveno","vigésimo"];
function ordName(n){ return ORD[n-1] || `${n}º`; }

/* corte por romanos */
function splitRomanIncisos(text){
  const src=(text||"").replace(/\r\n/g,"\n");
  const re=new RegExp(`(^|\\n)(${ROMANS.join("|")})\\)\\s`,"ig");
  const parts=[]; let m, marks=[];
  while((m=re.exec(src))!==null){ marks.push({idx: ROMANS.indexOf(m[2].toLowerCase())+1, start:m.index+(m[1]?m[1].length:0), end:re.lastIndex}); }
  if(!marks.length) return null;
  for(let i=0;i<marks.length;i++){
    const cur=marks[i], next=marks[i+1];
    const body=src.slice(cur.end, next?next.start:src.length).trim();
    parts.push({n:cur.idx, text:body});
  }
  const map=new Map(parts.map(p=>[p.n,p.text]));
  const order=parts.map(p=>p.n);
  return { map, order };
}

/* párrafos como incisos (cuando no hay romanos) */
function splitParagraphs(text){
  const paras = (text||"").replace(/\r\n/g,"\n").split(/\n\s*\n+/g).map(s=>s.trim()).filter(Boolean);
  return paras;
}

/* alineación por párrafos con ANCLAS y umbrales decrecientes */
function alignParagraphs(origParas, finalParas){
  const O = origParas, F = finalParas;
  const usedO = new Set();
  const matches = new Map(); // j (final) -> i (original)

  // Ancla 1º ↔ 1º si son razonablemente parecidos
  if (O.length && F.length){
    const s = jaccard(O[0], F[0]);
    if (s >= 0.85){ matches.set(0,0); usedO.add(0); }
  }
  // Ancla último ↔ último
  if (O.length>1 && F.length>1){
    const s = jaccard(O[O.length-1], F[F.length-1]);
    if (s >= 0.85 && ![...matches.values()].includes(O.length-1)){
      matches.set(F.length-1, O.length-1);
      usedO.add(O.length-1);
    }
  }

  function pass(THRESH){
    for(let j=0;j<F.length;j++){
      if(matches.has(j)) continue;
      let bestI=-1, bestS=0;
      for(let i=0;i<O.length;i++){
        if(usedO.has(i)) continue;
        const s=jaccard(O[i], F[j]);
        if(s>bestS){ bestS=s; bestI=i; }
      }
      if(bestS>=THRESH && bestI>=0){
        matches.set(j,bestI);
        usedO.add(bestI);
      }
    }
  }
  [0.995,0.99,0.97,0.94,0.90,0.85].forEach(pass);

  const added=[], removed=[], modified=[];
  // añadidos: finales sin match (su ordinal es j+1)
  for(let j=0;j<F.length;j++){
    if(!matches.has(j)) added.push({ n:j+1, ord:ordName(j+1), f:F[j] });
  }
  // removidos: originales sin match
  for(let i=0;i<O.length;i++){
    if(![...matches.values()].includes(i)) removed.push({ n:i+1, ord:ordName(i+1), o:O[i] });
  }
  // modificados: emparejados pero con diferencias
  for(const [j,i] of matches){
    const o=O[i], f=F[j];
    const same = normalizeForEquality(o)===normalizeForEquality(f) || jaccard(o,f)>=0.999;
    if(!same) modified.push({ n:j+1, ord:ordName(j+1), o, f });
  }
  return { modified, added, removed };
}

/* smart diff: usa romanos si existen; si no, párrafos */
function diffIncisosSmart(orig, fin){
  const R1=splitRomanIncisos(orig), R2=splitRomanIncisos(fin);
  if(R1 && R2){
    const modified=[], added=[], removed=[];
    const all=new Set([...(R1.order||[]),...(R2.order||[])]);
    all.forEach(n=>{
      const o=R1.map.get(n), f=R2.map.get(n);
      if(o && f){
        const same=normalizeForEquality(o)===normalizeForEquality(f) || jaccard(o,f)>=0.999;
        if(!same) modified.push({n,ord:ordName(n),o,f});
      } else if(!o && f){ added.push({n,ord:ordName(n),f}); }
      else if(o && !f){ removed.push({n,ord:ordName(n),o}); }
    });
    return { modified, added, removed };
  }
  return alignParagraphs(splitParagraphs(orig), splitParagraphs(fin));
}

/* literales y frases (pistas al LLM) */
function extractLiteralsMap(txt){
  const lines=(txt||"").split(/\r?\n/); const set=new Set();
  for(const ln of lines){ const m=ln.trim().match(/^([a-z])\)\s/i); if(m) set.add(m[1].toLowerCase()); }
  return set;
}
function literalHints(o,f){
  const O=extractLiteralsMap(o), F=extractLiteralsMap(f);
  const added=[...F].filter(x=>!O.has(x)).sort();
  const removed=[...O].filter(x=>!F.has(x)).sort();
  return {added, removed};
}
function phraseHints(o,f){
  const diffs = Diff.diffWords(o||"", f||"");
  const added=[], removed=[];
  for(const part of diffs){
    if(part.added){ const v=part.value.replace(/\s+/g," ").trim(); if(v.length>2) added.push(v); }
    if(part.removed){ const v=part.value.replace(/\s+/g," ").trim(); if(v.length>2) removed.push(v); }
  }
  return { added: added.slice(0,8), removed: removed.slice(0,8) };
}

/* ============== Prompt (JSON estricto) ============== */
function buildIndicationsPromptJSON(head, originalBlock, finalBlock, hints){
  const system = [
    "Eres un asesor legislativo chileno.",
    "Devuelve ÚNICAMENTE un JSON válido UTF-8 con este esquema:",
    '{"al_articulo":"AL ARTÍCULO [nombre completo]","indicaciones":["1) ...","   a) ..."]}',
    "Reglas:",
    "- Redacta en español normativo: Incorpórase, Agrégase, Añádese, Sustitúyese, Reemplázase, Intercálese, Suprímese, Elimínase, Modifícase.",
    "- Numera sólo dentro de este artículo (1), 2), …). La numeración global la hará el cliente.",
    "- Si NO corresponde ninguna indicación, devuelve indicaciones: [].",
    "- Debes cubrir CADA inciso modificado/suprimido/agregado de las pistas.",
    "- Para incisos AGREGADOS usa EXACTAMENTE: \"Incorpórese un nuevo inciso [ordinal], pasando el actual inciso [ordinal] a ser [ordinal siguiente], y así sucesivamente:\" y luego el tenor completo entre comillas. NUNCA uses \"Intercálese\" para incisos completos; \"Intercálese\" sólo aplica a frases dentro de un inciso.",
    "- Si NO hay incisos detectados pero hay diferencias, genera 1 indicación 'Para modificar el artículo en el siguiente sentido:' y desglosa a), b), c) con frases/expresiones agregadas o suprimidas.",
    `- Pistas incisos: modificados=[${hints.incisos.modified.map(x=>x.ord).join(", ")||"ninguno"}]; agregados=[${hints.incisos.added.map(x=>x.ord).join(", ")||"ninguno"}]; suprimidos=[${hints.incisos.removed.map(x=>x.ord).join(", ")||"ninguno"}].`,
    `- Pistas literales: agregados=[${hints.literals.added.join(", ")||"ninguno"}]; suprimidos=[${hints.literals.removed.join(", ")||"ninguno"}].`,
    `- Pistas frases+: agregadas=[${(hints.phrases.added||[]).map(s=>'"'+s+'"').join(", ")||"ninguna"}]; suprimidas=[${(hints.phrases.removed||[]).map(s=>'"'+s+'"').join(", ")||"ninguna"}].`,
    "- No repitas párrafos completos. Razona internamente y NO expliques tus pasos."
  ].join("\n");

  const user = [
    `Genera INDICACIONES para ${head} (caso A: modificación).`,
    "[Texto Original]", originalBlock,
    "[Texto Final]",   finalBlock
  ].join("\n\n");

  return { system, user };
}

/* ============== LLM (chat/completions con JSON) ============== */
async function askJSON(systemContent, userContent, model, apiKey){
  const url="https://api.openai.com/v1/chat/completions";
  const payload={
    model,
    response_format:{ type:"json_object" },
    messages:[{role:"system",content:systemContent},{role:"user",content:userContent}],
    temperature:0.0,
    max_tokens:1600
  };
  let lastErr;
  for(let i=0;i<5;i++){
    try{
      const res=await fetch(url,{
        method:"POST",
        headers:{ "Content-Type":"application/json","Authorization":`Bearer ${apiKey}` },
        body:JSON.stringify(payload)
      });
      if(res.ok){
        const data=await res.json();
        const text=data?.choices?.[0]?.message?.content||"";
        if(!text) throw new Error("Respuesta vacía.");
        return JSON.parse(text);
      }
      if((res.status===429||res.status>=500) && i<4){
        await new Promise(r=>setTimeout(r,(2**i)*1000 + Math.random()*500));
        continue;
      }
      throw new Error(`HTTP ${res.status}: ${await res.text()}`);
    }catch(e){ lastErr=e; await new Promise(r=>setTimeout(r,(2**i)*1000)); }
  }
  throw lastErr;
}

/* ============== Fallback determinístico (incisos nuevos correctos) ============== */
function deterministicIncisoBlock(head, incHints){
  const lines=[`AL ARTÍCULO ${head.replace(/^Artículo\s+/i,'')}`]; let n=1;
  for(const m of incHints.modified){
    lines.push(`${n++}) Para modificar su inciso ${m.ord} en el siguiente sentido:\n   a) Modifícase su texto conforme al comparado.`);
  }
  for(const r of incHints.removed){
    lines.push(`${n++}) Para suprimir el inciso ${r.ord}.`);
  }
  for(const a of incHints.added){
    const tenor=(a.f||"").replace(/"/g,'\\"');
    const nextOrd = ordName(a.n + 1);
    lines.push(`${n++}) Incorpórese un nuevo inciso ${a.ord}, pasando el actual inciso ${a.ord} a ser ${nextOrd}, y así sucesivamente: "${tenor}"`);
  }
  return lines.length>1 ? lines.join("\n") : "";
}
function deterministicArticleBlock(head, phrases){
  const lines=[`AL ARTÍCULO ${head.replace(/^Artículo\s+/i,'')}`, `1) Para modificar el artículo en el siguiente sentido:`];
  let code=97;
  for(const s of (phrases.removed||[])){ lines.push(`   ${String.fromCharCode(code++)}) Suprímese la expresión "${s}".`); if(code>122) break; }
  for(const s of (phrases.added||[])){ lines.push(`   ${String.fromCharCode(code++)}) Incorpórase la frase "${s}".`); if(code>122) break; }
  return lines.length>2 ? lines.join("\n") : "";
}

/* ============== Indicaciones por tipo ================= */
function makeInd_B(pair){
  const head = pair.final.header; const tenor = pair.final.text;
  return `AL ARTÍCULO ${head.replace(/^Artículo\s+/i,'')}\n1) Para agregar el siguiente artículo ${head.replace(/^Artículo\s+/i,'')}, nuevo, del siguiente tenor: "${tenor}"`;
}
function makeInd_C(pair){ const head=pair.original.header; return `AL ARTÍCULO ${head.replace(/^Artículo\s+/i,'')}\n1) Para suprimir el artículo ${head.replace(/^Artículo\s+/i,'')}.`; }
function makeInd_D(pair){ const ho=pair.original.header, hf=pair.final.header; return `AL ARTÍCULO ${ho.replace(/^Artículo\s+/i,'')}\n1) Para consignar que el artículo ${ho.replace(/^Artículo\s+/i,'')} ha pasado a ser ${hf.replace(/^Artículo\s+/i,'')}.`; }

/* ============== Normalizaciones ============== */
function ensureTopLevelNumbering(block){
  if(!block || !block.trim()) return block;
  const lines = block.split(/\r?\n/);
  const hasTop = lines.some(l => /^\s*\d+\)\s/.test(l));
  const onlyLetters = lines.slice(1).length>0 && lines.slice(1).every(l => /^\s*[A-Za-zÁÉÍÓÚÑa-záéíóúñ]\)\s/.test(l));
  if(!hasTop && onlyLetters){
    const al = lines[0].startsWith("AL ART") ? lines[0] : lines.shift();
    const sub = lines.filter(l=>/^\s*[A-Za-zÁÉÍÓÚÑa-záéíóúñ]\)\s/.test(l)).map(l=>`   ${l}`);
    return `${al}\n1) Para modificar el artículo en el siguiente sentido:\n${sub.join("\n")}`.trim();
  }
  return block;
}
function normalizeIncisoAdds(text, incHints){
  if(!text || !incHints || !incHints.added || !incHints.added.length) return text;
  const added = [...incHints.added];
  let used = 0;
  const lines = text.split(/\r?\n/).map((ln)=>{
    if(!/Interc(?:á|a)lese\s+(?:el\s+)?inciso\b/i.test(ln)) return ln;
    if(used >= added.length) return ln;
    const ad = added[used++];
    const nextOrd = ordName(ad.n + 1);
    let tenor = "";
    const mQ = ln.match(/:\s*(["“]?)([\s\S]*?)\1\s*$/);
    if (mQ && mQ[2]) {
      const raw = mQ[2].trim().replace(/^['"“”]+|['"“”]+$/g,"");
      if (raw) tenor = ` "${raw}"`;
    }
    const prefix = (ln.match(/^\s*[a-z]\)\s*/i) || [""])[0];
    return `${prefix}Incorpórese un nuevo inciso ${ad.ord}, pasando el actual inciso ${ad.ord} a ser ${nextOrd}, y así sucesivamente:${tenor}`;
  });
  return lines.join("\n");
}

/* ============== Numeración global (omite vacíos) ============== */
function renumberGlobally(blocks){
  let n=1; const out=[];
  for(const b of blocks){
    if(!b || !b.trim()){ out.push(""); continue; }
    const lines=b.split(/\r?\n/); const acc=[];
    for(const ln of lines){
      if(/^\s*\d+\)\s/.test(ln)){ acc.push(ln.replace(/^\s*\d+\)/, `${n++})`)); }
      else acc.push(ln);
    }
    out.push(acc.join("\n"));
  }
  return out;
}

/* ============== Render & export ============== */
function renderTable(articles){
  const container=$("resultsContainer"); container.innerHTML="";
  if(!articles.length){ container.innerHTML=`<p class="text-red-500">No hay artículos para mostrar.</p>`; return; }

  const table=document.createElement("table");
  table.id="resultsTable"; table.className="w-full border-collapse text-sm md:text-base";
  table.innerHTML=`
    <thead>
      <tr>
        <th class="w-1/3">Texto Original (con diffs)</th>
        <th class="w-1/3">Indicaciones</th>
        <th class="w-1/3">Texto Final (con diffs)</th>
      </tr>
    </thead>
    <tbody></tbody>`;
  const tbody=table.querySelector("tbody");

  articles.forEach(a=>{
    const diff=Diff.diffWords(a.original||"", a.final||"", {ignoreWhitespace:true});
    let oHtml="", fHtml="";
    diff.forEach(part=>{
      const s=escapeHtml(part.value);
      if(part.added) fHtml+=`<ins>${s}</ins>`;
      else if(part.removed) oHtml+=`<del>${s}</del>`;
      else { oHtml+=s; fHtml+=s; }
    });
    const tr=document.createElement("tr");
    tr.innerHTML=`
      <td class="align-top whitespace-pre-wrap">${oHtml}</td>
      <td class="align-top whitespace-pre-wrap">${sanitize(a.indicaciones || "")}</td>
      <td class="align-top whitespace-pre-wrap">${fHtml}</td>`;
    tbody.appendChild(tr);
  });

  container.appendChild(table);
  $("outputSection").classList.remove("hidden");
}
$("exportButton").onclick = ()=>{
  const table=$("resultsTable"); if(!table) return showError("No hay resultados para exportar.");
  const content = `
  <!DOCTYPE html><html><head><meta charset="UTF-8">
  <style>
    body{font-family:'Times New Roman',Times,serif;}
    table{border-collapse:collapse;width:100%;}
    th,td{border:1px solid #000;padding:8px;vertical-align:top;white-space:pre-wrap;}
    th{background:#f2f2f2;}
    ins{background:#d4edda;text-decoration:none;color:#000;}
    del{background:#f8d7da;text-decoration:line-through;color:#000;}
  </style></head><body>
    <h1>Tabla Comparativa de Indicaciones</h1>${table.outerHTML}
  </body></html>`;
  const blob = htmlDocx.asBlob(content);
  saveAs(blob, "Tabla_Comparativa_Indicaciones.docx");
};

/* ============== Orquestación principal ============== */
document.getElementById("generateButton").onclick = generate;

async function generate(){
  try{
    hideError(); $("debugLog").textContent="";
    const key = $("apiKey").value.trim();
    const model = ($("modelName").value.trim()) || "gpt-4o";
    const originalAll = $("originalText").value.trim();
    const finalAll    = $("finalText").value.trim();
    if(!key) return showError("Ingresa tu OpenAI API key.");
    if(!originalAll || !finalAll) return showError("Pega texto en ambas columnas.");
    if($("remember").checked){ localStorage.setItem("openai_key",key); localStorage.setItem("openai_model",model); }

    $("generateButton").disabled = true;
    $("resultsContainer").innerHTML = '<div class="loader"></div>';
    $("outputSection").classList.remove("hidden");
    $("timerResult").textContent=""; $("modelUsed").textContent="";
    const t0 = performance.now();

    const OB = splitArticles(originalAll);
    const FB = splitArticles(finalAll);
    dlog("Detectados — Original:", OB.length, "Final:", FB.length);
    if(!OB.length || !FB.length) throw new Error("No se detectaron encabezados 'Artículo …' en uno de los textos.");
    const pairs = orderPairsMerged(pairArticles(OB, FB), OB, FB);
    dlog("Pares/Clases:", pairs.map(p=>p.type).join(", "));

    const rows = [];
    for (const p of pairs){
      const originalBlock = p.original ? `${p.original.header}\n${p.original.text}` : "";
      const finalBlock    = p.final    ? `${p.final.header}\n${p.final.text}`       : "";

      if (p.type === 'A'){
        if (isNoChange(p.original.text, p.final.text)){
          rows.push({ original: originalBlock, final: finalBlock, indicaciones: "" });
          continue;
        }
        const incHints = diffIncisosSmart(p.original.text, p.final.text);
        const litHints = literalHints(p.original.text, p.final.text);
        const phrHints = phraseHints(p.original.text, p.final.text);
        const hints = { incisos: incHints, literals: litHints, phrases: phrHints };

        let obj;
        try{
          const { system, user } = buildIndicationsPromptJSON(p.final.header || p.original.header, originalBlock, finalBlock, hints);
          obj = await askJSON(system, user, model, key);
        }catch(e){
          console.warn("LLM falló, uso fallback:", e);
          obj = { al_articulo: "", indicaciones: [] };
        }

        const al  = (obj.al_articulo || `AL ARTÍCULO ${(p.final?.header||p.original?.header||"").replace(/^Artículo\s+/i,'')}`).trim();
        const arr = Array.isArray(obj.indicaciones)? obj.indicaciones.map(s=>String(s||"").trim()).filter(Boolean):[];
        let text = arr.length ? [al, ...arr].join("\n") : "";

        // Si devolvió sólo letras sin "1)", envolver
        const soloLetras = arr.length > 0
          && arr.every(l => /^\s*[a-z]\)\s/i.test(l))
          && !arr.some(l => /^\s*\d+\)\s/.test(l));
        if (soloLetras) {
          text = `${al}\n1) Para modificar el artículo en el siguiente sentido:\n` +
                 arr.map(l => `   ${l}`).join("\n");
        }

        // Corrige “Intercálese el inciso …” -> “Incorpórese un nuevo inciso …”
        text = normalizeIncisoAdds(text, incHints);

        if (!text && (incHints.modified.length || incHints.removed.length || incHints.added.length)){
          text = deterministicIncisoBlock(p.final?.header || p.original?.header || "Artículo", incHints);
        }
        if (!text && (phrHints.added.length || phrHints.removed.length)){
          text = deterministicArticleBlock(p.final?.header || p.original?.header || "Artículo", phrHints);
        }
        rows.push({ original: originalBlock, final: finalBlock, indicaciones: text });
      }
      else if (p.type === 'B'){ rows.push({ original: "", final: finalBlock, indicaciones: makeInd_B(p) }); }
      else if (p.type === 'C'){ rows.push({ original: originalBlock, final: "", indicaciones: makeInd_C(p) }); }
      else if (p.type === 'D'){ rows.push({ original: originalBlock, final: finalBlock, indicaciones: makeInd_D(p) }); }
    }

    // Blindaje: asegurar numeral superior si el modelo devolvió solo letras
    rows.forEach(r => { r.indicaciones = ensureTopLevelNumbering(r.indicaciones); });

    // Numeración global continua
    const renum = renumberGlobally(rows.map(r=>r.indicaciones));
    rows.forEach((r,i)=> r.indicaciones = renum[i]);

    renderTable(rows);

    const t1 = performance.now();
    $("timerResult").textContent = `(generado en ${((t1-t0)/1000).toFixed(1)}s; artículos: ${rows.length})`;
    $("modelUsed").textContent = `Modelo: ${model}`;
  }catch(err){
    showError(err.message || String(err));
  }finally{
    $("generateButton").disabled = false;
  }
}

/* ============== Errores globales ============== */
window.addEventListener("error",(e)=>{ showError("JS error: " + (e.message || e.error || "desconocido")); });
window.addEventListener("unhandledrejection",(e)=>{ showError("Promesa rechazada: " + (e.reason?.message || String(e.reason))); });
</script>
</body>
</html>
